[Previous](SQL-Statements-COMMIT-to-CREATE-JAVA.md) [Next](CREATE-ANALYTIC-
VIEW.md) JavaScript must be enabled to correctly display this content

  1. [SQL Language Reference ](index.md)
  2. [ SQL Statements: COMMIT to CREATE JAVA](SQL-Statements-COMMIT-to-CREATE-JAVA.md)
  3. COMMIT 

## COMMIT

Purpose

Use the `COMMIT` statement to end your current transaction and make permanent
all changes performed in the transaction. A transaction is a sequence of SQL
statements that Oracle Database treats as a single unit. This statement also
erases all savepoints in the transaction and releases transaction locks.

Until you commit a transaction:

  * You can see any changes you have made during the transaction by querying the modified tables, but other users cannot see the changes. After you commit the transaction, the changes are visible to other users' statements that execute after the commit. 

  * You can roll back (undo) any changes made during the transaction with the `ROLLBACK` statement (see [ROLLBACK](ROLLBACK.md#GUID-94551F0C-A47F-43DE-BC68-9B1C1ED38C93)). 

Oracle Database issues an implicit `COMMIT` under the following circumstances:

  * Before any syntactically valid data definition language (DDL) statement, even if the statement results in an error

  * After any data definition language (DDL) statement that completes without an error

You can also use this statement to:

  * Commit an in-doubt distributed transaction manually

  * Terminate a read-only transaction begun by a `SET` `TRANSACTION` statement 

Oracle recommends that you explicitly end every transaction in your
application programs with a `COMMIT` or `ROLLBACK` statement, including the
last transaction, before disconnecting from Oracle Database. If you do not
explicitly commit the transaction and the program terminates abnormally, then
the last uncommitted transaction is automatically rolled back.

A normal exit from most Oracle utilities and tools causes the current
transaction to be committed. A normal exit from an Oracle precompiler program
does not commit the transaction and relies on Oracle Database to roll back the
current transaction.

See Also:

  * [Oracle Database Concepts](/pls/topic/lookup?ctx=en/database/oracle/oracle-database/23/sqlrf&id=CNCPT016) for more information on transactions 

  * [SET TRANSACTION](SET-TRANSACTION.md#GUID-F11E1E30-5871-48D1-8266-F80A1DF126A1) for more information on specifying characteristics of a transaction 

Prerequisites

You need no privileges to commit your current transaction.

To manually commit a distributed in-doubt transaction that you originally
committed, you must have `FORCE` `TRANSACTION` system privilege. To manually
commit a distributed in-doubt transaction that was originally committed by
another user, you must have `FORCE` `ANY` `TRANSACTION` system privilege.

Syntax

commit::=

![Description of commit.eps
follows](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/img/commit.gif)  
[Description of the illustration commit.eps](img_text/commit.md)

Semantics

COMMIT

All clauses after the `COMMIT` keyword are optional. If you specify only
`COMMIT`, then the default is `COMMIT` `WORK` `WRITE` `WAIT` `IMMEDIATE`.

WORK

The `WORK` keyword is supported for compliance with standard SQL. The
statements `COMMIT` and `COMMIT` `WORK` are equivalent.

COMMENT Clause

This clause is supported for backward compatibility. Oracle recommends that
you use named transactions instead of commit comments.

See Also:

[SET TRANSACTION](SET-
TRANSACTION.md#GUID-F11E1E30-5871-48D1-8266-F80A1DF126A1) and [Oracle
Database Concepts](/pls/topic/lookup?ctx=en/database/oracle/oracle-
database/23/sqlrf&id=CNCPT1122) for more information on named transactions

Specify a comment to be associated with the current transaction. The '`text`'
is a quoted literal of up to 255 bytes that Oracle Database stores in the data
dictionary view `DBA_2PC_PENDING` along with the transaction ID if a
distributed transaction becomes in doubt. This comment can help you diagnose
the failure of a distributed transaction.

See Also:

[COMMENT](COMMENT.md#GUID-65F447C4-6914-4823-9691-F15D52DB74D7) for more
information on adding comments to SQL statements

WRITE Clause

Use this clause to specify the priority with which the redo information
generated by the commit operation is written to the redo log. This clause can
improve performance by reducing latency, thus eliminating the wait for an I/O
to the redo log. Use this clause to improve response time in environments with
stringent response time requirements where the following conditions apply:

  * The volume of update transactions is large, requiring that the redo log be written to disk frequently.

  * The application can tolerate the loss of an asynchronously committed transaction.

  * The latency contributed by waiting for the redo log write to occur contributes significantly to overall response time.

You can specify the `WAIT` | `NOWAIT` and `IMMEDIATE` | `BATCH` clauses in any order. 

Note:

If you omit this clause, then the behavior of the commit operation is
controlled by the `COMMIT_LOGGING` and `COMMIT_WAIT` initialization
parameters, if they have been set.

WAIT | NOWAIT

Use these clauses to specify when control returns to the user.

  * The `WAIT` parameter ensures that the commit will return only after the corresponding redo is persistent in the online redo log. Whether in `BATCH` or `IMMEDIATE` mode, when the client receives a successful return from this `COMMIT` statement, the transaction has been committed to durable media. A crash occurring after a successful write to the log can prevent the success message from returning to the client. In this case the client cannot tell whether or not the transaction committed. 

  * The `NOWAIT` parameter causes the commit to return to the client whether or not the write to the redo log has completed. This behavior can increase transaction throughput. With the `WAIT` parameter, if the commit message is received, then you can be sure that no data has been lost. 

Note:

With `NOWAIT`, a crash occurring after the commit message is received, but
before the redo log record(s) are written, can falsely indicate to a
transaction that its changes are persistent.

If you omit this clause, then the transaction commits with the `WAIT`
behavior.

IMMEDIATE | BATCH

Use these clauses to specify when the redo is written to the log.

  * The `IMMEDIATE` parameter causes the log writer process (LGWR) to write the transaction's redo information to the log. This operation option forces a disk I/O, so it can reduce transaction throughput. 

  * The `BATCH` parameter causes the redo to be buffered to the redo log, along with other concurrently executing transactions. When sufficient redo information is collected, a disk write of the redo log is initiated. This behavior is called "group commit", as redo for multiple transactions is written to the log in a single I/O operation. 

If you omit this clause, then the transaction commits with the `IMMEDIATE`
behavior.

See Also:

[Oracle Database Concepts](/pls/topic/lookup?ctx=en/database/oracle/oracle-
database/23/sqlrf&id=CNCPT1119) for more information on asynchronous commit

FORCE Clause

In a distributed database system, the `FORCE` `string` [, `integer`] clause
lets you manually commit an in-doubt distributed transaction. The transaction
is identified by the '`string`' containing its local or global transaction ID.
To find the IDs of such transactions, query the data dictionary view
`DBA_2PC_PENDING`. You can use `integer` to specifically assign the
transaction a system change number (SCN). If you omit `integer`, then the
transaction is committed using the current SCN.

Note:

A `COMMIT` statement with a `FORCE` clause commits only the specified
transactions. Such a statement does not affect your current transaction.

See Also:

[Oracle Database Administrator's
Guide](/pls/topic/lookup?ctx=en/database/oracle/oracle-
database/23/sqlrf&id=ADMIN032) for more information on these topics

Examples

Committing an Insert: Example

This statement inserts a row into the `hr.regions` table and commits this
change:

    
    
    INSERT INTO regions VALUES (5, 'Antarctica'); 
    
    COMMIT WORK;
     

To commit the same insert operation and instruct the database to buffer the
change to the redo log, without initiating disk I/O, use the following
`COMMIT` statement:

    
    
    COMMIT WRITE BATCH;

Commenting on COMMIT: Example

The following statement commits the current transaction and associates a
comment with it:

    
    
    COMMIT 
        COMMENT 'In-doubt transaction Code 36, Call (415) 555-2637'; 
    

If a network or machine failure prevents this distributed transaction from
committing properly, then Oracle Database stores the comment in the data
dictionary along with the transaction ID. The comment indicates the part of
the application in which the failure occurred and provides information for
contacting the administrator of the database where the transaction was
committed.

Forcing an In-Doubt Transaction: Example

The following statement manually commits a hypothetical in-doubt distributed
transaction. Query the `V$CORRUPT_XID_LIST` data dictionary view to find the
transaction IDs of corrupt transactions. You must have DBA privileges to view
the `V$CORRUPT_XID_LIST` and to issue this statement.

    
    
    COMMIT FORCE '22.57.53'; 


[← Previous](SQL-Statements-COMMIT-to-CREATE-JAVA.md)

[Next →](CREATE-ANALYTIC-VIEW.md)
